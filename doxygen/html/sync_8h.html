<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Snitch Runtime: sw/snRuntime/src/sync.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Snitch Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_01fcd3835fb4e7d9331b722d86291b65.html">sw</a></li><li class="navelem"><a class="el" href="dir_3f2371c4c09cc9a70279d3d318165699.html">snRuntime</a></li><li class="navelem"><a class="el" href="dir_b0ce412094ed5ce3b084eeef6c4b48b8.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sync.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file provides functions to synchronize Snitch cores.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;../../deps/riscv-opcodes/encoding.h&quot;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div>
<p><a href="sync_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad72d1461b9c336d13da30648df7a5649" id="r_ad72d1461b9c336d13da30648df7a5649"><td class="memItemLeft" align="right" valign="top"><a id="ad72d1461b9c336d13da30648df7a5649" name="ad72d1461b9c336d13da30648df7a5649"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNRT_BROADCAST_MASK</b>&#160;&#160;&#160;((SNRT_CLUSTER_NUM - 1) * SNRT_CLUSTER_OFFSET)</td></tr>
<tr class="separator:ad72d1461b9c336d13da30648df7a5649"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a572ae0f42550fc0d5551f167f2f64a7d" id="r_a572ae0f42550fc0d5551f167f2f64a7d"><td class="memItemLeft" align="right" valign="top"><a id="a572ae0f42550fc0d5551f167f2f64a7d" name="a572ae0f42550fc0d5551f167f2f64a7d"></a>
volatile uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>snrt_mutex</b> ()</td></tr>
<tr class="memdesc:a572ae0f42550fc0d5551f167f2f64a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a mutex variable. <br /></td></tr>
<tr class="separator:a572ae0f42550fc0d5551f167f2f64a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321bade577f4b200a5ad8aa37f281a61" id="r_a321bade577f4b200a5ad8aa37f281a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a321bade577f4b200a5ad8aa37f281a61">snrt_mutex_acquire</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:a321bade577f4b200a5ad8aa37f281a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a mutex, blocking.  <br /></td></tr>
<tr class="separator:a321bade577f4b200a5ad8aa37f281a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25632cce8737bb2726e18ed1b4f267cf" id="r_a25632cce8737bb2726e18ed1b4f267cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25632cce8737bb2726e18ed1b4f267cf">snrt_mutex_ttas_acquire</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:a25632cce8737bb2726e18ed1b4f267cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a mutex, blocking.  <br /></td></tr>
<tr class="separator:a25632cce8737bb2726e18ed1b4f267cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4e4b77fd2b4ce02f0235348745a57" id="r_ad0c4e4b77fd2b4ce02f0235348745a57"><td class="memItemLeft" align="right" valign="top"><a id="ad0c4e4b77fd2b4ce02f0235348745a57" name="ad0c4e4b77fd2b4ce02f0235348745a57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>snrt_mutex_release</b> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:ad0c4e4b77fd2b4ce02f0235348745a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously-acquired mutex. <br /></td></tr>
<tr class="separator:ad0c4e4b77fd2b4ce02f0235348745a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa8ee124ac2cc85ed5e6833bd49bbd4" id="r_a0aa8ee124ac2cc85ed5e6833bd49bbd4"><td class="memItemLeft" align="right" valign="top"><a id="a0aa8ee124ac2cc85ed5e6833bd49bbd4" name="a0aa8ee124ac2cc85ed5e6833bd49bbd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>snrt_wake_all</b> (uint32_t core_mask)</td></tr>
<tr class="separator:a0aa8ee124ac2cc85ed5e6833bd49bbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365cea67efa78cefdddecadf3e08d20" id="r_ac365cea67efa78cefdddecadf3e08d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a> ()</td></tr>
<tr class="memdesc:ac365cea67efa78cefdddecadf3e08d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize cores in a cluster with a hardware barrier, blocking.  <br /></td></tr>
<tr class="separator:ac365cea67efa78cefdddecadf3e08d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa540b1be9c7ddb48d1317e45e9b10a66" id="r_aa540b1be9c7ddb48d1317e45e9b10a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa540b1be9c7ddb48d1317e45e9b10a66">snrt_global_barrier</a> ()</td></tr>
<tr class="memdesc:aa540b1be9c7ddb48d1317e45e9b10a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize all Snitch cores.  <br /></td></tr>
<tr class="separator:aa540b1be9c7ddb48d1317e45e9b10a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009fca3dd0749c28446bf4a9f86cb211" id="r_a009fca3dd0749c28446bf4a9f86cb211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a009fca3dd0749c28446bf4a9f86cb211">snrt_partial_barrier</a> (<a class="el" href="structsnrt__barrier__t.html">snrt_barrier_t</a> *barr, uint32_t n)</td></tr>
<tr class="memdesc:a009fca3dd0749c28446bf4a9f86cb211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic software barrier.  <br /></td></tr>
<tr class="separator:a009fca3dd0749c28446bf4a9f86cb211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed7d49a94d35c044bc0701b9af191fd" id="r_a9ed7d49a94d35c044bc0701b9af191fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed7d49a94d35c044bc0701b9af191fd">snrt_global_all_to_all_reduction</a> (uint32_t value)</td></tr>
<tr class="memdesc:a9ed7d49a94d35c044bc0701b9af191fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a global sum reduction, blocking.  <br /></td></tr>
<tr class="separator:a9ed7d49a94d35c044bc0701b9af191fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae403013a77cae4a13263428ab21da248" id="r_ae403013a77cae4a13263428ab21da248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae403013a77cae4a13263428ab21da248">snrt_global_reduction_dma</a> (double *dst_buffer, double *src_buffer, size_t len)</td></tr>
<tr class="memdesc:ae403013a77cae4a13263428ab21da248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sum reduction among clusters, blocking.  <br /></td></tr>
<tr class="separator:ae403013a77cae4a13263428ab21da248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6988e3d8671188ea63fa9a127963ebcb" id="r_a6988e3d8671188ea63fa9a127963ebcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a> (uint32_t val)</td></tr>
<tr class="memdesc:a6988e3d8671188ea63fa9a127963ebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure value is written back to the register file.  <br /></td></tr>
<tr class="separator:a6988e3d8671188ea63fa9a127963ebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ac54c69b7bc3f1165277420cef710" id="r_a220ac54c69b7bc3f1165277420cef710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a220ac54c69b7bc3f1165277420cef710">snrt_enable_multicast</a> (uint32_t mask)</td></tr>
<tr class="memdesc:a220ac54c69b7bc3f1165277420cef710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable LSU multicast.  <br /></td></tr>
<tr class="separator:a220ac54c69b7bc3f1165277420cef710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3597f143342fb37d0564409eec33016" id="r_ae3597f143342fb37d0564409eec33016"><td class="memItemLeft" align="right" valign="top"><a id="ae3597f143342fb37d0564409eec33016" name="ae3597f143342fb37d0564409eec33016"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>snrt_disable_multicast</b> ()</td></tr>
<tr class="memdesc:ae3597f143342fb37d0564409eec33016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable LSU multicast. <br /></td></tr>
<tr class="separator:ae3597f143342fb37d0564409eec33016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides functions to synchronize Snitch cores. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac365cea67efa78cefdddecadf3e08d20" name="ac365cea67efa78cefdddecadf3e08d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac365cea67efa78cefdddecadf3e08d20">&#9670;&#160;</a></span>snrt_cluster_hw_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_cluster_hw_barrier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize cores in a cluster with a hardware barrier, blocking. </p>
<dl class="section note"><dt>Note</dt><dd>Synchronizes all (both DM and compute) cores. All cores must invoke this function, or the calling cores will stall indefinitely. </dd></dl>

</div>
</div>
<a id="a220ac54c69b7bc3f1165277420cef710" name="a220ac54c69b7bc3f1165277420cef710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220ac54c69b7bc3f1165277420cef710">&#9670;&#160;</a></span>snrt_enable_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_enable_multicast </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable LSU multicast. </p>
<p>All stores performed after this call will be multicast to all addresses specified by the address and mask pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Multicast mask value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ed7d49a94d35c044bc0701b9af191fd" name="a9ed7d49a94d35c044bc0701b9af191fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed7d49a94d35c044bc0701b9af191fd">&#9670;&#160;</a></span>snrt_global_all_to_all_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t snrt_global_all_to_all_reduction </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a global sum reduction, blocking. </p>
<p>All cores participate in the reduction and synchronize globally to wait for the reduction to complete. The synchronization is performed via snrt_global_barrier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be summed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the sum reduction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Every Snitch core must invoke this function, or the calling cores will stall indefinitely. </dd></dl>

</div>
</div>
<a id="aa540b1be9c7ddb48d1317e45e9b10a66" name="aa540b1be9c7ddb48d1317e45e9b10a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa540b1be9c7ddb48d1317e45e9b10a66">&#9670;&#160;</a></span>snrt_global_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_barrier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize all Snitch cores. </p>
<p>Synchronization is performed hierarchically. Within a cluster, cores are synchronized through a hardware barrier (see snrt_cluster_hw_barrier). Clusters are synchronized through a software barrier (see snrt_inter_cluster_barrier). </p><dl class="section note"><dt>Note</dt><dd>Every Snitch core must invoke this function, or the calling cores will stall indefinitely. </dd></dl>

</div>
</div>
<a id="ae403013a77cae4a13263428ab21da248" name="ae403013a77cae4a13263428ab21da248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae403013a77cae4a13263428ab21da248">&#9670;&#160;</a></span>snrt_global_reduction_dma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_reduction_dma </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>dst_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>src_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a sum reduction among clusters, blocking. </p>
<p>The reduction is performed in a logarithmic fashion. Half of the clusters active in every level of the binary-tree participate as as senders, the other half as receivers. Senders use the DMA to send their data to the respective receiver's destination buffer. The receiver then reduces each element in its destination buffer with the respective element in its source buffer. The result is stored in the source buffer. It then proceeds to the next level in the binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_buffer</td><td>The pointer to the calling cluster's destination buffer. </td></tr>
    <tr><td class="paramname">src_buffer</td><td>The pointer to the calling cluster's source buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data in each buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination buffers must lie at the same offset in every cluster's TCDM. </dd></dl>

</div>
</div>
<a id="a321bade577f4b200a5ad8aa37f281a61" name="a321bade577f4b200a5ad8aa37f281a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321bade577f4b200a5ad8aa37f281a61">&#9670;&#160;</a></span>snrt_mutex_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_acquire </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a mutex, blocking. </p>
<p>Test-and-set (TAS) implementation of a lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmtx</td><td>A pointer to a variable which can be used as a mutex, i.e. to which all cores have a reference and at a memory location to which atomic accesses can be made. This can be declared e.g. as <code>static volatile uint32_t mtx = 0;</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25632cce8737bb2726e18ed1b4f267cf" name="a25632cce8737bb2726e18ed1b4f267cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25632cce8737bb2726e18ed1b4f267cf">&#9670;&#160;</a></span>snrt_mutex_ttas_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_ttas_acquire </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a mutex, blocking. </p>
<p>Same as snrt_mutex_acquire but acquires the lock using a test and test-and-set (TTAS) strategy. </p>

</div>
</div>
<a id="a009fca3dd0749c28446bf4a9f86cb211" name="a009fca3dd0749c28446bf4a9f86cb211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009fca3dd0749c28446bf4a9f86cb211">&#9670;&#160;</a></span>snrt_partial_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_partial_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__barrier__t.html">snrt_barrier_t</a> *</td>          <td class="paramname"><span class="paramname"><em>barr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic software barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barr</td><td>pointer to a barrier variable. </td></tr>
    <tr><td class="paramname">n</td><td>number of harts that have to enter before released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Exactly the specified number of harts must invoke this function, or the calling cores will stall indefinitely. </dd></dl>

</div>
</div>
<a id="a6988e3d8671188ea63fa9a127963ebcb" name="a6988e3d8671188ea63fa9a127963ebcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6988e3d8671188ea63fa9a127963ebcb">&#9670;&#160;</a></span>snrt_wait_writeback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_wait_writeback </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure value is written back to the register file. </p>
<p>This function introduces a RAW dependency on val to stall the core until val is written back to the register file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The variable we want to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
